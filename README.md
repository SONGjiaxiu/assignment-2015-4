# Καταστροφή Δικτύου

Υπάρχουν διαφόρων ειδών δίκτυα: υπολογιστών, διανομής ρεύματος, συνδέσμων σε κοινωνικά δίκτυα, κ.ά. Κάποιες φορές χρειάζεται να βρούμε τον καλύτερο τρόπο να *καταστρέψουμε* ένα δίκτυο. Για παράδειγμα, σε ένα δίκτυο που αναπαριστά πιθανές σχέσεις μετάδοσης ασθενειών μεταξύ ανθρώπων, όπου οι κόμβοι είναι οι άνθρωποι οι οποίοι συνδέονται με άλλους ανθρώπους στους οποίους μπορούν να μεταδώσουν μία νόσο, μπορούμε να αποτρέψουμε μια επιδημία αν εντοπίσουμε ποιους ανθρώπους πρέπει να εμβολιάσουμε ώστε πλέον η ασθένεια να μην μπορεί να μεταδωθεί. Σε ένα άλλο παράδειγμα, αν μεταδίδεται μια ψευδής πληροφορία μέσω ενός κοινωνικού δικτύου, μπορούμε να σταματήσουμε τη μετάδοσή της αν στοχεύσουμε σε συγκεκριμένα μέλη ενός δικτύου τα οποία παίζουν ιδιαιτέρως σημαντικό ρόλο στη μετάδοση της πληροφορίας.

Για την καταστροφή ενός δικτύου πρέπει λοιπόν να εντοπίσουμε τους κόμβους εκείνους οι οποίοι έχουν τη μεγαλύτερη επιρροή στο συνολικό δίκτυο. Ένας τρόπος είναι να εργαστούμε ως εξής:

1. Εντοπίζουμε τον κόμβο με το μεγαλύτερο αριθμό συνδέσμων.
2. Αφαιρούμε αυτόν τον κόμβο.
3. Επιστρέφουμε στο βήμα 1.

Στην παρακάτω εικόνα μπορείτε να δείτε πώς καταστρέφουμε ένα δίκτυο αφαιρώντας τους τέσσερεις κόμβους με τον μεγαλύτερο κάθε φορά αριθμό συνδέσμων.

![Network Destruction 1](/network-destruction-1.png)

Με τον τρόπο αυτό, βλέπουμε ότι μετά από την αφαίρεση τεσσάρων κόμβων, το μεγαλύτερο συνδεδεμένο κομμάτι (commented component) του δικτύου περιέχει 17 κόμβους.

Ένας άλλος τρόπος εργασίας είναι σε πολλά δίκτυα πιο αποτελεσματικός. Αντί να θεωρούμε ότι ο κόμβος με τη μεγαλύτερη επιρροή είναι αυτός με τους περισσότερους συνδέσμους, ορίζουμε τη *συνολική επιρροή* (collective influence) ενός κόμβου ως εξής:

![Collective Influence](/ci_definition.png)

Το πρόγραμμά σας θα πρέπει να διαβάζει ένα τέτοιο αρχείο, να βρίσκει συχνά στοιχειοσύνολα σύμφωνα με το κατώφλι που θα δίνει ο χρήστης, και να εξάγει αποτελέσματα σε μορφή `CSV`.

## Απαιτήσεις Προγράμματος

Κάθε φοιτητής θα εργαστεί στο προσωπικό του αποθετήριο στο GitHub. Για να αξιολογηθεί μια εργασία θα πρέπει να πληροί τις παρακάτω προϋποθέσεις:

1. Όλη η εργασία θα πρέπει να βρίσκεται σε έναν κατάλογο `assignment-2015-3` μέσα στο αποθετήριο του φοιτητή.

2. Το πρόγραμμα θα πρέπει να έχει όνομα `a_priori.py`.

3. Το πρόγραμμα θα μπορεί να καλείται ως εξής:
```bash
python a_priori.py [-n] [-p] [-o OUTPUT] support filename
```
Οι αγκύλες δεν αποτελούν μέρος των πραγμάτων που δίνει ο χρήστης, απλώς χρησιμεύουν για να μας υπενθυμίζουν στην περιγραφή του προγράμματος ότι η συγκεκριμένη παράμετρος είναι προαιρετική. Έτσι έχουμε:

  * Η παράμετρος `-n` είναι προαιρετική. Αν δίνεται η παράμετρος`-n`, το πρόγραμμα θα θεωρεί ότι τα αντικείμενα είναι αριθμητικά (όχι strings). Αλλιώς θα τα θεωρεί strings.
  * Η παράμετρος `-p` είναι προαιρετική. Αν δίνεται η παράμετρος `-p`, το πρόγραμμα θα θεωρεί ότι η ελάχιστη τιμή υποστήριξης που δίνεται μέσω της παραμέτρου `-s` είναι το *ποσοστό* των καλαθιών στα οποία θα πρέπει να βρίσκεται ένα συνολοστοιχείο για να θεωρηθεί σημαντικό.
  * Η παράμετρος `-o OUTPUT` είναι προαιρετική. Αν δίνεται η παράμετρος `-o` το πρόγραμμα θα σώζει τα αποτελέσματα στο αρχείο `OUTPUT`. Αλλιώς θα τα εμφανίζει στην οθόνη. 
  * Η παράμετρος `support` είναι υποχρεωτική. Με αυτήν δίνεται η ελάχιστη τιμή υποστήριξης (support) που θα χρησιμοποιεί ο αλγόριθμος για τον χαρακτηρισμό των συχνών συνολοστοιχείων.
  * Η παράμετρος `filename` είναι υποχρεωτική. Με αυτήν δίνεται το όνομα του αρχείου εισόδου του προγράμματος.
 
Για παράδειγμα, μπορούμε να καλέσουμε το πρόγραμμα ως εξής:

```
python a_priori.py -n 2 a_priori_example_2.csv
```
το οποίο σημαίνει ότι θα διαβαστεί το αρχείο `a_priori_example_2.csv`, τα περιεχόμενα του οποίου θα ερμηνευτούν ως αριθμητικά, η υποστήριξη θα έχει κατώφλι το 2, και τα αποτελέσματα θα εμφανιστούν στην οθόνη.

Αν δώσουμε:

```
python a_priori.py -p -o a_prior_example_1_results.csv 20 a_priori_example_1.csv
```

θα διαβαστεί το αρχείο `a_priori_example_1.csv`, τα περιεχόμενα του οποίου θα ερμηνευτούν ως string, η υποστήριξη θα έχει κατώφλι το 20% του συνόλου των εγγραφών, και τα αποτελέσματα θα αποθηκευτούν στο αρχείο `a_prior_example_1_results.csv`.

Το πρόγραμμα θα παράγει το αποτέλεσμα με μορφή `CSV`, όπου ο διαχωριστής θα είναι ο χαρακτήρας `;`. Κάθε γραμμή θα είναι της μορφής:
```
itemset_1:support;itemset_2:support;...itemset_n:support
```
όπου κάθε `itemset` θα είναι της μορφής:

* `(item,)` (αν αποτελείται από ένα αντικείμενο)
* `(item_1, item_2, ..., item_n)` αν αποτελείται από `n` αντικείμενα.

*Προσοχή*: ο λόγος που ζητείται το κάθε itemset να είναι της μορφής `(item,)` αν πρόκειται για μόνο ένα αντικείμενο είναι για τη διευκόλυνσή σας. Είναι πιθανό ότι για την καταμέτρηση των συχνοτήτων των itemsets θα χρησιμοποιήσετε λεξικά. Στα λεξικά τα κλειδιά δεν μπορεί να είναι λίστες ή σύνολα, μπορεί να είναι όπως tuples. Ένα tuple με ένα μόνο στοιχείο item μέσα του αναπαρίσταται στην Python ως `(item,)`.

Έτσι αν στο αρχείο που δώσαμε παραπάνω ως παράδειγμα ζητούσαμε στήριξη 3, θα παίρναμε στην έξοδο:
```
('a',):3;('and',):4;('cat',):5;('dog',):6;('training',):3
('and', 'cat'):3;('and', 'dog'):3;('cat', 'dog'):4
```

Δείγματα αρχείων εισόδου και εξόδου του προγράμματος:

* [example_1.csv](example_1.csv), με στήριξη 3 θα δώσει έξοδο:
```
('a',):3;('and',):4;('cat',):5;('dog',):6;('training',):3
('and', 'cat'):3;('and', 'dog'):3;('cat', 'dog'):4
```
* [example_2.csv](example_2.csv), με στήριξη 2 και θεωρώντας τα αντικείμενα αριθμητικά θα δώσει έξοδο:
```
(1,):2;(2,):3;(3,):3;(5,):3
(1, 3):2;(2, 3):2;(2, 5):3;(3, 5):2
(2, 3, 5):2
```
* [example_3.csv](example_3.csv), με στήριξη 2 και θεωρώντας τα αντικείμενα αριθμητικά θα δώσει έξοδο:
```
(1,):3;(2,):6;(3,):4;(4,):5
(1, 2):3;(1, 4):2;(2, 3):3;(2, 4):4;(3, 4):3
(1, 2, 4):2;(2, 3, 4):2
```
