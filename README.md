# Καταστροφή Δικτύου

Υπάρχουν διαφόρων ειδών δίκτυα: υπολογιστών, διανομής ρεύματος, συνδέσμων σε κοινωνικά δίκτυα, κ.ά. Κάποιες φορές χρειάζεται να βρούμε τον καλύτερο τρόπο να *καταστρέψουμε* ένα δίκτυο. Για παράδειγμα, σε ένα δίκτυο που αναπαριστά πιθανές σχέσεις μετάδοσης ασθενειών μεταξύ ανθρώπων, όπου οι κόμβοι είναι οι άνθρωποι οι οποίοι συνδέονται με άλλους ανθρώπους στους οποίους μπορούν να μεταδώσουν μία νόσο, μπορούμε να αποτρέψουμε μια επιδημία αν εντοπίσουμε ποιους ανθρώπους πρέπει να εμβολιάσουμε ώστε πλέον η ασθένεια να μην μπορεί να μεταδωθεί. Σε ένα άλλο παράδειγμα, αν μεταδίδεται μια ψευδής πληροφορία μέσω ενός κοινωνικού δικτύου, μπορούμε να σταματήσουμε τη μετάδοσή της αν στοχεύσουμε σε συγκεκριμένα μέλη ενός δικτύου τα οποία παίζουν ιδιαιτέρως σημαντικό ρόλο στη μετάδοση της πληροφορίας.

Για την καταστροφή ενός δικτύου πρέπει λοιπόν να εντοπίσουμε τους κόμβους εκείνους οι οποίοι έχουν τη μεγαλύτερη επιρροή στο συνολικό δίκτυο. Ένας τρόπος είναι να εργαστούμε ως εξής:

1. Εντοπίζουμε τον κόμβο με το μεγαλύτερο αριθμό συνδέσμων.
2. Αφαιρούμε αυτόν τον κόμβο.
3. Επιστρέφουμε στο βήμα 1.

Επαναλαμβάνουμε τα βήματα 1-3 όσες φορές θέλουμε.

Στην παρακάτω εικόνα μπορείτε να δείτε πώς καταστρέφουμε ένα δίκτυο αφαιρώντας τους τέσσερεις κόμβους με τον μεγαλύτερο κάθε φορά αριθμό συνδέσμων.

![Network Destruction 1](/network-destruction-1.png)

Με τον τρόπο αυτό, βλέπουμε ότι μετά από την αφαίρεση τεσσάρων κόμβων, το μεγαλύτερο συνδεδεμένο κομμάτι (commented component) του δικτύου περιέχει 17 κόμβους.

Ένας άλλος τρόπος εργασίας είναι σε πολλά δίκτυα πιο αποτελεσματικός. Αντί να θεωρούμε ότι ο κόμβος με τη μεγαλύτερη επιρροή είναι αυτός με τους περισσότερους συνδέσμους, ορίζουμε τη *συνολική επιρροή* (collective influence) ενός κόμβου ως εξής:

![Collective Influence](/ci_definition.png)

Στον παραπάνω ορισμό, ![i definition](/i_definition.png) είναι ο κόμβος του οποίου υπολογίζουμε τη συνολική επιρροή, ![ki definition](/ki_definition.png) είναι ο αριθμός συνδέσμων του κόμβου ![i definition](/i_definition.png), και ![Theta Ball definition](/theta_ball_definition.png) είναι το σύνολο των κόμβων των οποίων το συντομότερο μονοπάτι από τον κόμβο ![i definition](/i_definition.png) έχει μήκος ![r definition](/r_definition.png).

Με άλλα λόγια, για να υπολογίσουμε τη συνολική επιρροή ενός κόμβου, βρίσκουμε τους κόμβους που το συντομότερο μονοπάτι τους από τον κόμβο ![i definition](/i_definition.png) είναι ίσο ![r definition](/r_definition.png) και σχηματίζουμε το άθροισμα που προκύπτει από τον αριθμό συνδέσμων του καθενός από αυτούς τους κόμβους μείον ένα. Στη συνέχεια πολλαπλασιάζουμε το αποτέλεσμα με τον αριθμό συνδέσμων του κόμβου ![i definition](/i_definition.png) μείον ένα.

Συνεπώς για να καταστρέψουμε ένα δίκτυο χρησιμοποιώντας τη συνολική επιρροή, εργαζόμαστε ως εξής:

1. Εντοπίζουμε τον κόμβο με τη μεγαλύτερη συνολική επιρροή.
2. Αφαιρούμε αυτόν τον κόμβο.
3. Επιστρέφουμε στο βήμα 1.

Επαναλαμβάνουμε τα βήματα 1-3 όσες φορές θέλουμε.

Στην παρακάτω εικόνα μπορείτε να δείτε πώς καταστρέφουμε ένα δίκτυο αφαιρώντας τους τέσσερεις κόμβους με τη μεγαλύτερη κάθε φορά συνολική επιρροή.

![Network Destruction 2](/network-destruction-2.png)

Με τον τρόπο αυτό, βλέπουμε ότι μετά από την αφαίρεση ήδη τριών κόμβων, το μεγαλύτερο συνδεδεμένο κομμάτι του δικτύου περιέχει 9 μόνο κόμβους. Άρα ήδη με τρεις κόμβους έχουμε επιτύχει καλύτερη καταστροφή από ό,τι με τέσσερεις κόμβους με την προηγούμενη μέθοδο.

## Απαιτήσεις Προγράμματος

Κάθε φοιτητής θα εργαστεί στο προσωπικό του αποθετήριο στο GitHub. Για να αξιολογηθεί μια εργασία θα πρέπει να πληροί τις παρακάτω προϋποθέσεις:

1. Όλη η εργασία θα πρέπει να βρίσκεται σε έναν κατάλογο `assignment-2015-4` μέσα στο αποθετήριο του φοιτητή.

2. Το πρόγραμμα θα πρέπει να έχει όνομα `network_destruction.py`.

3. Το πρόγραμμα θα μπορεί να καλείται ως εξής:
```bash
python network_destruction.py [-n] [-p] [-o OUTPUT] filename
```
Οι αγκύλες δεν αποτελούν μέρος των πραγμάτων που δίνει ο χρήστης, απλώς χρησιμεύουν για να μας υπενθυμίζουν στην περιγραφή του προγράμματος ότι η συγκεκριμένη παράμετρος είναι προαιρετική. Έτσι έχουμε:

  * Η παράμετρος `-n` είναι προαιρετική. Αν δίνεται η παράμετρος`-n`, το πρόγραμμα θα θεωρεί ότι τα αντικείμενα είναι αριθμητικά (όχι strings). Αλλιώς θα τα θεωρεί strings.
  * Η παράμετρος `-p` είναι προαιρετική. Αν δίνεται η παράμετρος `-p`, το πρόγραμμα θα θεωρεί ότι η ελάχιστη τιμή υποστήριξης που δίνεται μέσω της παραμέτρου `-s` είναι το *ποσοστό* των καλαθιών στα οποία θα πρέπει να βρίσκεται ένα συνολοστοιχείο για να θεωρηθεί σημαντικό.
  * Η παράμετρος `-o OUTPUT` είναι προαιρετική. Αν δίνεται η παράμετρος `-o` το πρόγραμμα θα σώζει τα αποτελέσματα στο αρχείο `OUTPUT`. Αλλιώς θα τα εμφανίζει στην οθόνη. 
  * Η παράμετρος `support` είναι υποχρεωτική. Με αυτήν δίνεται η ελάχιστη τιμή υποστήριξης (support) που θα χρησιμοποιεί ο αλγόριθμος για τον χαρακτηρισμό των συχνών συνολοστοιχείων.
  * Η παράμετρος `filename` είναι υποχρεωτική. Με αυτήν δίνεται το όνομα του αρχείου εισόδου του προγράμματος.
 
Για παράδειγμα, μπορούμε να καλέσουμε το πρόγραμμα ως εξής:

```
python a_priori.py -n 2 a_priori_example_2.csv
```
το οποίο σημαίνει ότι θα διαβαστεί το αρχείο `a_priori_example_2.csv`, τα περιεχόμενα του οποίου θα ερμηνευτούν ως αριθμητικά, η υποστήριξη θα έχει κατώφλι το 2, και τα αποτελέσματα θα εμφανιστούν στην οθόνη.

Αν δώσουμε:

```
python a_priori.py -p -o a_prior_example_1_results.csv 20 a_priori_example_1.csv
```

θα διαβαστεί το αρχείο `a_priori_example_1.csv`, τα περιεχόμενα του οποίου θα ερμηνευτούν ως string, η υποστήριξη θα έχει κατώφλι το 20% του συνόλου των εγγραφών, και τα αποτελέσματα θα αποθηκευτούν στο αρχείο `a_prior_example_1_results.csv`.

Το πρόγραμμα θα παράγει το αποτέλεσμα με μορφή `CSV`, όπου ο διαχωριστής θα είναι ο χαρακτήρας `;`. Κάθε γραμμή θα είναι της μορφής:
```
itemset_1:support;itemset_2:support;...itemset_n:support
```
όπου κάθε `itemset` θα είναι της μορφής:

* `(item,)` (αν αποτελείται από ένα αντικείμενο)
* `(item_1, item_2, ..., item_n)` αν αποτελείται από `n` αντικείμενα.

*Προσοχή*: ο λόγος που ζητείται το κάθε itemset να είναι της μορφής `(item,)` αν πρόκειται για μόνο ένα αντικείμενο είναι για τη διευκόλυνσή σας. Είναι πιθανό ότι για την καταμέτρηση των συχνοτήτων των itemsets θα χρησιμοποιήσετε λεξικά. Στα λεξικά τα κλειδιά δεν μπορεί να είναι λίστες ή σύνολα, μπορεί να είναι όπως tuples. Ένα tuple με ένα μόνο στοιχείο item μέσα του αναπαρίσταται στην Python ως `(item,)`.

Έτσι αν στο αρχείο που δώσαμε παραπάνω ως παράδειγμα ζητούσαμε στήριξη 3, θα παίρναμε στην έξοδο:
```
('a',):3;('and',):4;('cat',):5;('dog',):6;('training',):3
('and', 'cat'):3;('and', 'dog'):3;('cat', 'dog'):4
```

Δείγματα αρχείων εισόδου και εξόδου του προγράμματος:

* [example_1.csv](example_1.csv), με στήριξη 3 θα δώσει έξοδο:
```
('a',):3;('and',):4;('cat',):5;('dog',):6;('training',):3
('and', 'cat'):3;('and', 'dog'):3;('cat', 'dog'):4
```
* [example_2.csv](example_2.csv), με στήριξη 2 και θεωρώντας τα αντικείμενα αριθμητικά θα δώσει έξοδο:
```
(1,):2;(2,):3;(3,):3;(5,):3
(1, 3):2;(2, 3):2;(2, 5):3;(3, 5):2
(2, 3, 5):2
```
* [example_3.csv](example_3.csv), με στήριξη 2 και θεωρώντας τα αντικείμενα αριθμητικά θα δώσει έξοδο:
```
(1,):3;(2,):6;(3,):4;(4,):5
(1, 2):3;(1, 4):2;(2, 3):3;(2, 4):4;(3, 4):3
(1, 2, 4):2;(2, 3, 4):2
```
